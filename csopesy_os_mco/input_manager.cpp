#include "input_manager.h"
const static std::vector<std::regex> command_list = {
	//(std::regex)"(invalid)",			    //-1
	(std::regex)"(initialize)", 			//0
	(std::regex)"(exit)", 					//1
	(std::regex)R"(screen -s (\S+))",		//2
	(std::regex)"(screen -ls)",				//3
	(std::regex)"(scheduler-start)",		//4
	(std::regex)"(scheduler-stop)",			//5
	(std::regex)"(report-util)",			//6
	(std::regex)"(marquee)",				//7
	(std::regex)"(clear)",					//8
	(std::regex)"(nvidia-smi)",				//9
	(std::regex)R"(screen -r (\S+))",		//10
	(std::regex)"(d)",		//11
	(std::regex)"(process-smi)"		//12



};

const static std::vector<std::string> command_strings = {
	"exit",		// 8
	"initialize",	// 0
	"screen",		// 1
	"scheduler-start",	//2
	"scheduler-stop",		//3
	"report-util",		//4
	"marquee",				//5
	"clear",				//6
	"nvidia-smi"			//7
};

const static std::vector<std::string> screen_options = {
	"-s",
	"-d",
	"-ls",
	"-r"
};
InputMan::InputMan() {

	this->indexLoopCommandMain = 0;
	this->indexLoopCommandOptions = 0;

}




void InputMan::Input(std::string& input, int& sKeys, bool& isCmdDone) {

	if (_kbhit()) {
		char key = _getch();
		//std::cerr << "Key pressed (char): '" << key << "' (int: " << static_cast<int>(key) << ")";

		// Check if it's an extended key
		if (key == 0 || key == 224) {
			// It's an extended key, so get the actual key code
			key = _getch(); // Read the second byte for extended keys

			switch (key) {
				case 72: // Up arrow
					sKeys = 72;
					// No need to add to 'input' for arrow keys
					break;
				case 80: // Down arrow
					sKeys = 80;
					// No need to add to 'input' for arrow keys
					break;

				default:
					sKeys = -1;
					// You can add debugging here if you want to see other extended key codes
					// std::cout << "Unhandled extended key code: " << key << std::endl;
					break;
			}

		}
		else if (key == 72 || key == 80 || key == 75 || key ==77 || key == 9)
		{
			switch (key) {
			case 72: // Up arrow
				sKeys = 72;
				// No need to add to 'input' for arrow keys
				break;
			case 75: // Left arrow
				this->indexLoopCommandMain--;
				if (this->indexLoopCommandMain < 0)
					this->indexLoopCommandMain = (STRING_COMMANDS_INDEX_MAX)-1;
				input = command_strings.at(indexLoopCommandMain);
				break;
			case 77: // Right arrow
				this->indexLoopCommandMain = (this->indexLoopCommandMain+1) % (STRING_COMMANDS_INDEX_MAX);
				input = command_strings.at(this->indexLoopCommandMain);

				break;
			case 80: // Down arrow
				sKeys = 80;
				// No need to add to 'input' for arrow keys
				break;
			case 9:
				this->indexLoopCommandOptions = (this->indexLoopCommandOptions+1) % 3;
				if (input.find("screen") != std::string::npos)
					input = "screen " + screen_options.at(this->indexLoopCommandOptions);
				break;
			default:
				sKeys = -1;
				// You can add debugging here if you want to see other extended key codes
				// std::cout << "Unhandled extended key code: " << key << std::endl;
				break;
			}
		}
		else {

			// It's a regular character or symbol key
			switch (key) {
			case '\r': // Enter key (often '\r' on Windows)
			case '\n': // Sometimes '\n' is also returned or preferred for consistency
				if ((input).length() != 0) {
					isCmdDone = true;
				}
				break;
			case 8:
				if (!input.empty()) { // Ensure input is not empty before popping
					input.pop_back();
				}
				break;
			case -32:		//trash value generated by arrow keys
				break;
			default:

				input += key;
				isCmdDone = false;
				break;
			}
		}
		





	}
}
void InputMan::CLI_Comms(std::string& input, int& action, bool& isCmdDone, std::smatch& match) {


	bool is_valid = false;
	bool is_key = false;
	if (isCmdDone) {

		for (int i = 0; i < command_list.size(); i++) {
			if (regex_match(input, match, command_list[i])) {

				is_valid = true;
				action = i;
				i = command_list.size();
			}
		}
		if (!is_valid) {
			action = -1;
		}
		input = "";
		isCmdDone = false;

	}

}



